import React, { useRef, useEffect, useState, useMemo } from 'react';
import styles from './TechnologiesList.module.css';

interface ConnectionLinesProps {
  itemRefs: Array<{ current: HTMLDivElement | null }>;
  containerRef: React.RefObject<HTMLElement | null>;
  timelineRef?: React.RefObject<HTMLElement | null>;
  hoveredTech: string | null;
}

type ConnectionLine = {
  id: string;
  startX: number;
  startY: number;
  endX: number;
  endY: number;
  visible: boolean;
  isHighlighted?: boolean;
};

const ConnectionLines: React.FC<ConnectionLinesProps> = ({ itemRefs, hoveredTech }) => {
  const svgRef = useRef<SVGSVGElement>(null);
  const [_, setForceUpdate] = useState(0);
  const rafId = useRef<number | null>(null);
  const isMounted = useRef(true);

  // Handle cleanup on unmount
  useEffect(() => {
    return () => {
      isMounted.current = false;
      if (rafId.current) {
        cancelAnimationFrame(rafId.current);
      }
    };
  }, []);

  // Generate connection lines between tech items and cards
  const connectionLines = useMemo(() => {
    const lines: ConnectionLine[] = [];
    if (typeof window === 'undefined') return lines;
    
    const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
    
    // Helper function to check if a point is in the viewport
    const isInViewport = (y: number) => y >= 0 && y <= viewportHeight;
    
    itemRefs.forEach((ref, index) => {
      if (!ref.current) return;
      
      const techName = ref.current.getAttribute('data-tech-name');
      if (!techName) return;
      
      const isHighlighted = hoveredTech === null || hoveredTech === techName;
      const rect = ref.current.getBoundingClientRect();
      const startX = rect.right;
      const startY = rect.top + rect.height / 2;
      
      // Query cards for this technology
      try {
        const selector = `[data-card-technologies*="${techName}"]`;
        const cardElements = document.querySelectorAll(selector);
        
        cardElements.forEach((element, cardIndex) => {
          const cardRect = element.getBoundingClientRect();
          const cardX = cardRect.left + cardRect.width / 2;
          const cardY = cardRect.top + cardRect.height / 2;
          
          // Only draw if either point is in the viewport
          if (isInViewport(startY) || isInViewport(cardY)) {
            lines.push({
              id: `line-${index}-${cardIndex}-${techName}`,
              startX,
              startY,
              endX: cardX,
              endY: cardY,
              visible: true,
              isHighlighted
            });
          }
        });
      } catch (error) {
        console.error('Error processing cards for tech:', techName, error);
      }
    });
    
    return lines;
  }, [itemRefs, hoveredTech]);

  // Function to create a curved path between two points
  const createCurvedPath = (startX: number, startY: number, endX: number, endY: number) => {
    // Control points for the curve
    const cp1x = startX + (endX - startX) / 3;
    const cp1y = startY;
    const cp2x = endX - (endX - startX) / 3;
    const cp2y = endY;
    
    return `M${startX},${startY} C${cp1x},${cp1y} ${cp2x},${cp2y} ${endX},${endY}`;
  };

  // Update lines on window resize or scroll
  useEffect(() => {
    const handleResize = () => {
      if (rafId.current) {
        cancelAnimationFrame(rafId.current);
      }
      rafId.current = requestAnimationFrame(() => {
        setForceUpdate(prev => prev + 1);
      });
    };

    window.addEventListener('resize', handleResize);
    window.addEventListener('scroll', handleResize, { passive: true });
    
    return () => {
      window.removeEventListener('resize', handleResize);
      window.removeEventListener('scroll', handleResize);
      if (rafId.current) {
        cancelAnimationFrame(rafId.current);
      }
    };
  }, []);

  // Don't render if no valid connection lines
  if (connectionLines.length === 0) {
    return null;
  }

  return (
    <svg
      ref={svgRef}
      className={styles.connectionLines}
      style={{
        position: 'fixed',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        pointerEvents: 'none',
        zIndex: 1,
      }}
    >
      {connectionLines.map((line) => (
        <path
          key={line.id}
          d={createCurvedPath(line.startX, line.startY, line.endX, line.endY)}
          className={`${styles.connectionLine} ${line.isHighlighted ? styles.highlighted : ''}`}
          fill="none"
          strokeWidth={line.isHighlighted ? 2 : 1}
        />
      ))}
    </svg>
  );
};

export default ConnectionLines;
